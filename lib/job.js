// Generated by CoffeeScript 1.12.1
(function() {
  var Job, Rabbot, Timeout, _,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  _ = require('lodash');

  Rabbot = require('rabbot');

  Timeout = require('callback-timeout');

  module.exports = Job = (function() {
    function Job(type, queue) {
      this.type = type;
      this.queue = queue;
      this.processCallback = bind(this.processCallback, this);
      this.processLogMeta = bind(this.processLogMeta, this);
      this.connection = this.queue.connection;
      this.stats = this.connection.stats;
      this.log = this.connection.log;
    }

    Job.prototype.mergePublishOptions = function(body, options) {
      this.queue.lastPublish = Date.now();
      options = _.defaultsDeep({}, options, this.queue.options, {
        type: this.type,
        publishedAt: Date.now(),
        headers: {},
        attempts: 0,
        maxAttempts: 1,
        initialDelay: 0,
        delay: 1000,
        id: this.queue.options.id + 1,
        body: body
      });
      if (options.messageId == null) {
        options.messageId = this.queue.options.name + '.' + (++this.queue.options.id);
      }
      options.routingKey = options.type = this.type;
      delete options.timeout;
      _.defaults(options.headers, _.pick(options, ['attempts', 'maxAttempts', 'delay', 'publishedAt']));
      if (options.headers.attempts > 0 && options.headers.delay) {
        options.headers['x-delay'] = options.headers.delay * Math.pow(2, options.headers.attempts - 1);
      } else if (options.initialDelay) {
        options.headers['x-delay'] = options.initialDelay;
      }
      return _.pick(options, ['headers', 'messageId', 'routingKey', 'type', 'body']);
    };

    Job.prototype.hasAttemptsRemaining = function(arg) {
      var headers;
      headers = arg.headers;
      return headers.attempts < headers.maxAttempts;
    };

    Job.prototype.publish = function(body, options, cb) {
      options = this.mergePublishOptions(body, options);
      if (!this.hasAttemptsRemaining(options)) {
        this.log.info({
          type: this.type
        }, "Rejecting publish due to too many attempts: " + options.headers.attempts + " >= " + options.headers.maxAttempts);
        return false;
      }
      this.log.info({
        type: this.type,
        id: options.messageId
      }, 'Publishing job to queue', options);
      return Rabbot.publish(this.connection.exchange.name, options).then(function(res) {
        return typeof cb === "function" ? cb(null, res) : void 0;
      })["catch"](cb);
    };

    Job.prototype.request = function(body, options, cb) {
      options = this.mergePublishOptions(body, options);
      if (options.replyTimeout == null) {
        options.replyTimeout = 5000;
      }
      options.headers.reply = true;
      if (!this.hasAttemptsRemaining(options)) {
        this.log.info({
          type: this.type
        }, "Rejecting publish due to too many attempts: " + options.headers.attempts + " >= " + options.headers.maxAttempts);
        return false;
      }
      this.log.info({
        type: this.type,
        id: options.messageId
      }, 'Requesting job in queue', options);
      return Rabbot.request(this.connection.exchange.name, options).then(function(res) {
        try {
          res.ack();
        } catch (error) {}
        return typeof cb === "function" ? cb(null, res) : void 0;
      })["catch"](cb);
    };

    Job.prototype.partFailure = function(message) {
      var base;
      return typeof (base = this.queue).partFailure === "function" ? base.partFailure(message) : void 0;
    };

    Job.prototype.fullFailure = function(message) {
      var base;
      return typeof (base = this.queue).fullFailure === "function" ? base.fullFailure(message) : void 0;
    };

    Job.prototype.process = function(message) {
      var err, headers;
      headers = message.properties.headers;
      headers.attempts += 1;
      headers.startedAt = Date.now();
      this.stats('timing', this.type, 'startDelay', Date.now() - message.properties.timestamp);
      message.attempt = headers.attempts;
      message.firstAttempt = message.attempt === 1;
      message.lastAttempt = headers.attempts >= headers.maxAttempts;
      message.retry = function(val) {
        if (val == null) {
          val = true;
        }
        return message.shouldRetry = val;
      };
      message.finish = (function(_this) {
        return function() {
          if (headers.reply) {
            _this.log.info('REPLYING', arguments);
            return message.reply.apply(message, arguments);
          } else {
            _this.log.info('ACKING', arguments);
            return message.ack();
          }
        };
      })(this);
      this.log.info(this.processLogMeta(message, {
        timeout: this.queue.options.timeout
      }), 'Starting');
      try {
        return this.queue.options.process(message, Timeout(this.processCallback.bind(this, message), this.queue.options.timeout));
      } catch (error) {
        err = error;
        return this.processCallback(message, err, err);
      }
    };

    Job.prototype.processLogMeta = function(message, extra) {
      return _.extend(extra, {
        type: this.type,
        id: message.properties.messageId,
        attempt: message.attempt,
        delaySinceStarted: Date.now() - message.properties.headers.startedAt,
        delaySincePublished: Date.now() - message.properties.headers.publishedAt
      });
    };

    Job.prototype.processCallback = function(message, err, result) {
      var headers;
      try {
        headers = message.properties.headers;
        this.stats('timing', this.type, 'e2e', Date.now() - headers.publishedAt);
        this.stats('timing', this.type, 'run', Date.now() - headers.startedAt);
        if (err && (result != null ? result.retry : void 0) !== false && message.shouldRetry !== false && !message.lastAttempt) {
          message.finish({
            ok: false,
            final: false,
            result: err
          });
          this.stats('increment', this.type, 'part_fail', 1);
          if (typeof this.partFailure === "function") {
            this.partFailure(message);
          }
          this.queue.publish(message.body, message.properties);
          this.log.error(this.processLogMeta(message), 'Failed and retrying', err);
          return false;
        }
        if (err) {
          message.finish({
            ok: false,
            final: true,
            result: err
          });
          this.stats('increment', this.type, 'full_fail', 1);
          if (typeof this.fullFailure === "function") {
            this.fullFailure(message);
          }
          this.log.error(this.processLogMeta(message, {
            retry: result != null ? result.retry : void 0,
            lastAttempt: message.lastAttempt
          }), "Failed completely", err);
          return false;
        }
        message.finish({
          ok: true,
          final: true,
          result: result
        });
        this.queue.lastComplete = Date.now();
        this.stats('increment', this.type, 'ok', 1);
        this.log.info(this.processLogMeta(message), 'Completed without error', result);
        return true;
      } catch (error) {
        err = error;
        message.finish({
          ok: false,
          final: false,
          result: err
        });
        return this.log.error('processCallback error', err);
      }
    };

    return Job;

  })();

}).call(this);

//# sourceMappingURL=job.js.map
