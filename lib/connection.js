// Generated by CoffeeScript 1.12.1
(function() {
  var Connection, Queue, Rabbot, _;

  _ = require('lodash');

  Rabbot = require('rabbot');

  Queue = require('./queue');

  module.exports = Connection = (function() {
    function Connection(options) {
      this.options = _.defaultsDeep(options, {
        log: new console.Console(process.stdout, process.stderr),
        stats: function(type, queue, stat, value) {
          return null;
        },
        connection: {
          uri: 'amqp://guest:guest@localhost/'
        },
        exchange: {
          name: 'beatrix',
          autoDelete: false,
          durable: true,
          type: 'x-delayed-message',
          "arguments": {
            'x-delayed-type': 'direct'
          }
        },
        onUnhandled: function(message) {
          this.log.error('Unhandled message', message);
          return message.ack();
        }
      });
      this.exchange = this.options.exchange;
      this.log = this.options.log;
      this.stats = this.options.stats;
      this.onUnhandled = this.options.onUnhandled;
      this.queues = {};
      _.each(options.queues, (function(_this) {
        return function(opts, name) {
          return _this.queues[name] = {
            publish: function() {
              return _this.queues[name].stack.push(['publish', arguments]);
            },
            request: function() {
              return _this.queues[name].stack.push(['request', arguments]);
            },
            stack: []
          };
        };
      })(this));
    }

    Connection.prototype.connect = function(cb) {
      Rabbot.onUnhandled(this.onUnhandled.bind(this));
      return Rabbot.configure({
        connection: this.options.connection,
        exchanges: [this.options.exchange]
      }).then((function(_this) {
        return function() {
          cb(null, _this);
          return _this;
        };
      })(this))["catch"]((function(_this) {
        return function(err) {
          cb(err, _this);
          return _this;
        };
      })(this));
    };

    Connection.prototype.createQueue = function(name, options, cb) {
      var queue, ref, stack;
      stack = (ref = this.queues[name]) != null ? ref.stack : void 0;
      this.queues[name] = queue = new Queue(name, options, this);
      return this.queues[name].connect(function(err) {
        var i, item, len;
        if (err) {
          return typeof cb === "function" ? cb(err) : void 0;
        }
        for (i = 0, len = stack.length; i < len; i++) {
          item = stack[i];
          queue[item[0]].apply(queue, item[1]);
        }
        return typeof cb === "function" ? cb(null, queue) : void 0;
      });
    };

    Connection.prototype.partFailure = function(message) {
      var base;
      return typeof (base = this.options).partFailure === "function" ? base.partFailure(message) : void 0;
    };

    Connection.prototype.fullFailure = function(message) {
      var base;
      return typeof (base = this.options).fullFailure === "function" ? base.fullFailure(message) : void 0;
    };

    return Connection;

  })();

}).call(this);

//# sourceMappingURL=connection.js.map
