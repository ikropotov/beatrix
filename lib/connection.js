// Generated by CoffeeScript 1.12.1
(function() {
  var Connection, Queue, Rabbot, _;

  _ = require('lodash');

  Rabbot = require('rabbot');

  Queue = require('./queue');

  module.exports = Connection = (function() {
    function Connection(options) {
      this.options = _.defaultsDeep(options, {
        log: new console.Console(process.stdout, process.stderr),
        stats: function(type, queue, stat, value) {
          return null;
        },
        connection: {
          uri: 'amqp://guest:guest@localhost/'
        },
        exchange: {
          name: 'beatrix',
          autoDelete: false,
          durable: true,
          "arguments": {}
        },
        onUnhandled: function(message) {
          this.log.error('Unhandled message', message);
          return message.ack();
        }
      });
      this.exchange = this.options.exchange;
      this.log = this.options.log;
      this.stats = this.options.stats;
      this.onUnhandled = this.options.onUnhandled;
      this.queues = {};
      this.options.exchange.type = 'x-delayed-message';
      this.options.exchange["arguments"]['x-delayed-type'] = 'direct';
    }

    Connection.prototype.connect = function(cb) {
      Rabbot.onUnhandled(this.onUnhandled.bind(this));
      return Rabbot.configure({
        connection: this.options.connection,
        exchanges: [this.options.exchange]
      }).then((function(_this) {
        return function() {
          cb(null, _this);
          return _this;
        };
      })(this))["catch"]((function(_this) {
        return function(err) {
          cb(err, _this);
          return _this;
        };
      })(this));
    };

    Connection.prototype.createQueue = function(name, options, cb) {
      this.queues[name] = new Queue(name, options, this);
      return this.queues[name].connect(cb);
    };

    Connection.prototype.partFailure = function(message) {
      var base;
      return typeof (base = this.options).partFailure === "function" ? base.partFailure(message) : void 0;
    };

    Connection.prototype.fullFailure = function(message) {
      var base;
      return typeof (base = this.options).fullFailure === "function" ? base.fullFailure(message) : void 0;
    };

    return Connection;

  })();

}).call(this);

//# sourceMappingURL=connection.js.map
