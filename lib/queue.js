// Generated by CoffeeScript 1.12.1
(function() {
  var Job, Queue, Rabbot, _;

  _ = require('lodash');

  Rabbot = require('rabbot');

  Job = require('./job');

  module.exports = Queue = (function() {
    function Queue(name1, options, connection) {
      var ref, ref1, ref2;
      this.name = name1;
      this.connection = connection;
      this.log = this.connection.log;
      this.stats = this.connection.stats;
      this.options = _.defaultsDeep(options, {
        name: this.name,
        type: this.connection.exchange.name + '.' + this.name,
        timeout: null,
        concurrency: 1,
        id: 0
      });
      this.handle = false;
      this.connected = false;
      this.stack = (ref = (ref1 = this.connection.queues) != null ? (ref2 = ref1[this.name]) != null ? ref2.stack : void 0 : void 0) != null ? ref : [];
      this.lastPublish = 0;
      this.lastComplete = 0;
    }

    Queue.prototype.createHandle = function() {
      var concurrency, name, noBatch, ref, ref1, type;
      ref = this.options, name = ref.name, type = ref.type, concurrency = ref.concurrency, noBatch = ref.noBatch;
      if ((ref1 = this.handle) != null) {
        if (typeof ref1.remove === "function") {
          ref1.remove();
        }
      }
      this.handle = Rabbot.handle({
        queue: type,
        type: type,
        autoNack: true,
        handler: this.processJob,
        context: this
      });
      return Rabbot.addQueue(type, {
        subscribe: true,
        autoDelete: false,
        durable: true,
        noBatch: noBatch !== false,
        limit: concurrency
      }).then((function(_this) {
        return function(internalQueue) {
          _this.internalQueue = internalQueue;
          return Rabbot.bindQueue(_this.connection.exchange.name, type, [type]);
        };
      })(this));
    };

    Queue.prototype.connect = function(cb) {
      var concurrency, name, ref, type;
      ref = this.options, name = ref.name, type = ref.type, concurrency = ref.concurrency;
      return this.createHandle().then((function(_this) {
        return function() {
          _this.log.info({
            type: type,
            concurrency: concurrency
          }, "RabbitMQ Queue Started");
          setInterval((function() {
            var state;
            state = _.get(_this.internalQueue, 'state');
            if (state !== 'subscribed') {
              _this.internalQueue.subscribe();
              return _this.log.error({
                type: type
              }, 'Resubscribing queue, state was: ' + state);
            }
          }), 1000);
          setInterval((function() {
            var lag, timeout;
            if (_this.lastPublish) {
              lag = _this.lastPublish - _this.lastComplete;
              timeout = (_this.options.timeout | 0) || 60 * 1000;
              _this.stats('timing', type, 'lag', Math.abs(lag));
              if (_this.lastPublish > 0 && Math.abs(Date.now() - _this.lastComplete) > Math.max(2 * timeout, 10 * 1000)) {
                _this.log.info({
                  type: type
                }, 'Rebinding Queue');
                _this.createHandle();
                _this.lastPublish = 0;
                return _this.lastComplete = 0;
              }
            }
          }), 10 * 1000);
          _this.connected = true;
          setTimeout((function() {
            var i, item, len, ref1, results;
            ref1 = _this.stack;
            results = [];
            for (i = 0, len = ref1.length; i < len; i++) {
              item = ref1[i];
              results.push(_this[item.type](item.body, item.options, item.cb));
            }
            return results;
          }), 100);
          return typeof cb === "function" ? cb(null, _this) : void 0;
        };
      })(this))["catch"]((function(_this) {
        return function(err) {
          _this.log.error({
            type: type
          }, "Could not initialise queue", err);
          _this.connected = false;
          return cb("Could not initialise queue: " + err.stack, _this);
        };
      })(this));
    };

    Queue.prototype.publish = function(body, options, cb) {
      var job;
      if (!this.connected) {
        return this.stack.push({
          type: 'publish',
          body: body,
          options: options,
          cb: cb
        });
      }
      job = new Job(this.options.type, this);
      return job.publish(body, options, cb);
    };

    Queue.prototype.request = function(body, options, cb) {
      var job;
      if (!this.connected) {
        return this.stack.push({
          type: 'request',
          body: body,
          options: options,
          cb: cb
        });
      }
      job = new Job(this.options.type, this);
      return job.request(body, options, cb);
    };

    Queue.prototype.processJob = function(message) {
      var job;
      job = new Job(this.options.type, this);
      return job.process(message);
    };

    Queue.prototype.partFailure = function(message) {
      var base, base1;
      if (typeof (base = this.options).partFailure === "function") {
        base.partFailure(message);
      }
      return typeof (base1 = this.connection).partFailure === "function" ? base1.partFailure(message) : void 0;
    };

    Queue.prototype.fullFailure = function(message) {
      var base, base1;
      if (typeof (base = this.options).fullFailure === "function") {
        base.fullFailure(message);
      }
      return typeof (base1 = this.connection).fullFailure === "function" ? base1.fullFailure(message) : void 0;
    };

    return Queue;

  })();

}).call(this);

//# sourceMappingURL=queue.js.map
